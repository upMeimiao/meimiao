// Generated by CoffeeScript 1.8.0
(function() {
  var Client, Connection, Delete, EventEmitter, Get, Increment, ProtoBuf, Put, Scan, ZooKeeperWatcher, async, builder, crypto, debug, hconstants, md5sum, proto, rDebug, utils, zkDebug, zkProto,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  debug = (require('debug'))('hbase-client');

  rDebug = (require('debug'))('hbase-region');

  zkDebug = (require('debug'))('zk');

  zkProto = require('./zk-protobuf');

  utils = require('./utils');

  crypto = require('crypto');

  async = require('async');

  hconstants = require('./hconstants');

  Connection = require('./connection');

  Get = require('./get');

  Put = require('./put');

  Delete = require('./delete');

  Increment = require('./increment');

  Scan = require('./scan').Scan;

  ZooKeeperWatcher = require('zookeeper-watcher');

  EventEmitter = require('events').EventEmitter;

  ProtoBuf = require("protobufjs");

  ProtoBuf.convertFieldsToCamelCase = true;

  builder = ProtoBuf.loadProtoFile("" + __dirname + "/../proto/Client.proto");

  proto = builder.build();

  md5sum = function(data) {
    return crypto.createHash('md5').update(data).digest('hex');
  };

  module.exports = Client = (function(_super) {
    __extends(Client, _super);

    function Client(options) {
      this._clearCachedLocationForServer = __bind(this._clearCachedLocationForServer, this);
      this._handleConnectionClose = __bind(this._handleConnectionClose, this);
      this._handleConnectionError = __bind(this._handleConnectionError, this);
      this.getRegionConnection = __bind(this.getRegionConnection, this);
      this.prefetchRegionCache = __bind(this.prefetchRegionCache, this);
      this.processBatch = __bind(this.processBatch, this);
      this.incrementColumnValue = __bind(this.incrementColumnValue, this);
      this.increment = __bind(this.increment, this);
      this.mdelete = __bind(this.mdelete, this);
      this.mput = __bind(this.mput, this);
      this.mget = __bind(this.mget, this);
      this["delete"] = __bind(this["delete"], this);
      this.put = __bind(this.put, this);
      this.checkAndDelete = __bind(this.checkAndDelete, this);
      this.checkAndPut = __bind(this.checkAndPut, this);
      this.get = __bind(this.get, this);
      this.getScanner = __bind(this.getScanner, this);
      this._multiAction = __bind(this._multiAction, this);
      this._action = __bind(this._action, this);
      this.getCachedLocation = __bind(this.getCachedLocation, this);
      this.cacheLocation = __bind(this.cacheLocation, this);
      this.locateRegionInMeta = __bind(this.locateRegionInMeta, this);
      this.locateRegion = __bind(this.locateRegion, this);
      this.ensureZookeeperTrackers = __bind(this.ensureZookeeperTrackers, this);
      this._zkWatch = __bind(this._zkWatch, this);
      Client.__super__.constructor.call(this);
      options.zookeeperRoot = options.zookeeperRoot || "/hbase";
      if (options.zookeeper && typeof options.zookeeper.quorum === "string") {
        options.zookeeperHosts = options.zookeeper.quorum.split(SERVERNAME_SEPARATOR);
      }
      this.zk = new ZooKeeperWatcher({
        hosts: options.zookeeperHosts,
        root: options.zookeeperRoot
      });
      this.servers = {};
      this.cachedRegionLocations = {};
      this.rpcTimeout = options.rpcTimeout || hconstants.RPC_TIMEOUT;
      this.pingTimeout = options.pingTimeout || hconstants.PING_TIMEOUT;
      this.callTimeout = options.callTimeout || hconstants.CALL_TIMEOUT;
      this.zkStart = "init";
      this._zkStartListener = [];
      this.rootRegionZKPath = options.rootRegionZKPath || '/meta-region-server';
      this._prefetchRegionCacheList = {};
      this._prefetchRegionCacheListInProgress = {};
      this.ensureZookeeperTrackers((function(_this) {
        return function(err) {
          if (err) {
            return _this.emit('error', err);
          }
        };
      })(this));
    }

    Client.prototype._zkWatch = function() {
      this.zk.unWatch(this.rootRegionZKPath);
      return this.zk.watch(this.rootRegionZKPath, (function(_this) {
        return function(err, value, zstat) {
          var firstStart, oldServer, rootServer, serverName;
          firstStart = _this.zkStart !== "done";
          if (err) {
            setTimeout(function() {
              return _this._zkWatch();
            }, hconstants.SOCKET_RETRY_WAIT_MS);
            zkDebug("[%s] [worker:%s] [hbase-client] zookeeper watch error: %s", new Date(), process.pid, err.stack);
            if (firstStart) {
              _this.zkStart = "error";
              _this.emit("error", err);
            }
            return;
          }
          _this.zkWatchTimeoutCount = 1;
          rootServer = zkProto.decodeMeta(value);
          if (!rootServer) {
            console.log("Failed to parse rootServer");
            return;
          }
          _this.zkStart = "done";
          oldServer = _this.rootServer || {
            server: {
              hostName: 'none',
              port: 'none'
            }
          };
          _this.rootServer = rootServer.server;
          serverName = _this.getServerName(_this.rootServer);
          return _this.getRegionConnection(serverName, function(err, server) {
            if (err) {
              return cb(err);
            }
            zkDebug("zookeeper start done, got new root " + serverName + ", old " + (oldServer != null ? oldServer.hostName : void 0) + ":" + (oldServer != null ? oldServer.port : void 0));
            if (firstStart) {
              return _this.emit("ready");
            }
          });
        };
      })(this));
    };

    Client.prototype.ensureZookeeperTrackers = function(cb) {
      if (this.zkStart === "done") {
        return cb();
      }
      this._zkStartListener.push(cb);
      if (this.zkStart === "starting") {
        return;
      }
      this.zkStart = "starting";
      this.once('ready', (function(_this) {
        return function() {
          var callback, _results;
          _results = [];
          while (_this._zkStartListener.length) {
            callback = _this._zkStartListener.pop();
            _results.push(callback());
          }
          return _results;
        };
      })(this));
      return this.zk.once("connected", (function(_this) {
        return function(err) {
          if (err) {
            _this.zkStart = "error";
            zkDebug("[%s] [worker:%s] [hbase-client] zookeeper connect error: %s", new Date(), process.pid, err.stack);
            return _this.emit("ready", err);
          }
          return _this._zkWatch();
        };
      })(this));
    };

    Client.prototype.getServerName = function(hostname, port) {
      if (typeof hostname === 'object') {
        port = hostname.port;
        hostname = hostname.hostName;
      }
      return "" + hostname + ":" + port;
    };

    Client.prototype.locateRegion = function(table, row, useCache, cb) {
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
      }
      rDebug("locateRegion table: " + table + " row: " + row);
      if (!Buffer.isBuffer(table)) {
        table = new Buffer(table);
      }
      row = new Buffer(row || [0]);
      return this.ensureZookeeperTrackers((function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          }
          return _this.locateRegionInMeta(table, row, useCache, cb);
        };
      })(this));
    };

    Client.prototype.locateRegionInMeta = function(table, row, useCache, cb) {
      var o, region, req;
      rDebug("locateRegionInMeta table: " + table + " row: " + row);
      region = this.createRegionName(table, row, '', true);
      if (utils.bufferCompare(table, hconstants.META_TABLE_NAME) === 0) {
        o = {
          startKey: new Buffer(0),
          endKey: new Buffer(0),
          name: hconstants.META_REGION_NAME,
          server: this.getServerName(this.rootServer.hostName, this.rootServer.port)
        };
        return cb(null, o);
      }
      req = {
        region: {
          type: "REGION_NAME",
          value: hconstants.META_REGION_NAME
        },
        gxt: {
          row: region,
          column: {
            family: "info"
          },
          closestRowBefore: true
        }
      };
      return this.prefetchRegionCache(table, (function(_this) {
        return function() {
          var cachedRegion;
          if (useCache) {
            cachedRegion = _this.getCachedLocation(table, row);
            if (cachedRegion) {
              return cb(null, cachedRegion);
            }
          }
          return _this.getRegionConnection(_this.rootServer.hostName, _this.rootServer.port, function(err, server) {
            return server.rpc.Get(req, function(err, response) {
              if (err) {
                rDebug("locateRegionInMeta error: " + err);
                return cb(err);
              }
              if (response != null ? response.result : void 0) {
                region = _this._parseRegionInfo(_this._parseResponse(response.result));
              }
              if (!region.server) {
                err = "region for table " + table + " not found";
                cb(err);
                return rDebug(err);
              }
              _this.cacheLocation(table, region);
              return cb(null, region);
            });
          });
        };
      })(this));
    };

    Client.prototype._parseRegionInfo = function(res) {
      var region, regionInfo;
      if (!Object.keys(res).length) {
        return null;
      }
      regionInfo = res.cols['info:regioninfo'].value;
      regionInfo = regionInfo.slice(regionInfo.toString().indexOf('PBUF') + 4);
      regionInfo = proto.RegionInfo.decode(regionInfo);
      region = {
        server: res.cols['info:server'].value,
        startKey: regionInfo.startKey.toBuffer(),
        endKey: regionInfo.endKey.toBuffer(),
        name: res.row,
        ts: res.cols['info:server'].timestamp.toString()
      };
      return region;
    };

    Client.prototype.cacheLocation = function(table, region) {
      var _base;
      if ((_base = this.cachedRegionLocations)[table] == null) {
        _base[table] = {};
      }
      return this.cachedRegionLocations[table][region.name] = region;
    };

    Client.prototype.getCachedLocation = function(table, row) {
      var cachedRegion, cachedRegions, endKey, startKey, _i, _len;
      rDebug("Trying to find cached regionLocation for table " + table);
      if (!(this.cachedRegionLocations[table] && Object.keys(this.cachedRegionLocations[table]).length > 0)) {
        return null;
      }
      cachedRegions = Object.keys(this.cachedRegionLocations[table]);
      for (_i = 0, _len = cachedRegions.length; _i < _len; _i++) {
        cachedRegion = cachedRegions[_i];
        startKey = this.cachedRegionLocations[table][cachedRegion].startKey;
        endKey = this.cachedRegionLocations[table][cachedRegion].endKey;
        if ((endKey.length === 0 || utils.bufferCompare(row, endKey) <= 0) && (startKey.length === 0 || utils.bufferCompare(row, startKey) > 0)) {
          rDebug("Found cached regionLocation " + cachedRegion);
          return this.cachedRegionLocations[table][cachedRegion];
        }
      }
      rDebug("Didn't find cached regionLocation for table " + table);
      return null;
    };

    Client.prototype.printRegion = function(region) {
      var o;
      return o = {
        startKey: region.startKey.toString(),
        endKey: region.endKey.toString(),
        name: region.name.toString(),
        ts: region.ts.toString(),
        server: region.server.toString()
      };
    };

    Client.prototype._parseResponse = function(res) {
      var cols, columns, o, row, _ref;
      if (!(res != null ? (_ref = res.cell) != null ? _ref.length : void 0 : void 0)) {
        return null;
      }
      row = null;
      cols = {};
      columns = res.cell.map(function(cell) {
        var f, o, q, t, v;
        row = cell.row.toBuffer();
        f = cell.family.toBuffer();
        q = cell.qualifier.toBuffer();
        v = cell.value.toBuffer();
        t = cell.timestamp;
        o = {
          value: v,
          timestamp: t
        };
        if (cols["" + f + ":" + q]) {
          if (!Array.isArray(cols["" + f + ":" + q])) {
            cols["" + f + ":" + q] = [cols["" + f + ":" + q]];
          }
          cols["" + f + ":" + q].push(o);
        } else {
          cols["" + f + ":" + q] = o;
        }
        return {
          family: f,
          qualifier: q,
          value: v,
          timestamp: t
        };
      });
      o = {
        row: row,
        cols: cols,
        columns: columns
      };
      return o;
    };

    Client.prototype.createRegionName = function(table, startKey, id, newFormat) {
      var b, delim, md5;
      if (!Buffer.isBuffer(table)) {
        table = new Buffer(table);
      }
      startKey = new Buffer(startKey || 0);
      id = new Buffer((id != null ? id.toString() : void 0) || 0);
      delim = new Buffer(',');
      b = Buffer.concat([table, delim, startKey, delim, id]);
      md5 = new Buffer(md5sum(b));
      delim = new Buffer('.');
      if (newFormat) {
        return Buffer.concat([b, delim, md5, delim]);
      }
      return b;
    };

    Client.prototype._action = function(method, table, obj, useCache, retry, cb) {
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
        retry = 0;
      } else if (typeof retry === 'function') {
        cb = retry;
        retry = 0;
      }
      return this.locateRegion(table, obj.row, useCache, (function(_this) {
        return function(err, location) {
          if (err) {
            return cb(err);
          }
          return _this.getRegionConnection(location.server.toString(), function(err, server) {
            var comparator, req;
            if (err) {
              return cb(err);
            }
            if (method === 'get') {
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                gxt: obj.getFields()
              };
              return server.rpc.Get(req, function(err, response) {
                if (err) {
                  return cb(err);
                }
                return cb(null, _this._parseResponse(response.result));
              });
            } else if (method === 'put' || method === 'delete' || method === 'increment') {
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                mutation: obj.getFields()
              };
              return server.rpc.Mutate(req, cb);
            } else if (method === 'checkAndPut' || method === 'checkAndDelete') {
              comparator = new proto.BinaryComparator({
                comparable: {
                  value: obj.value
                }
              });
              req = {
                region: {
                  type: "REGION_NAME",
                  value: location.name
                },
                mutation: obj.op.getFields(),
                condition: {
                  row: obj.row,
                  family: obj.family,
                  qualifier: obj.qualifier,
                  compareType: 'EQUAL',
                  comparator: {
                    name: 'org.apache.hadoop.hbase.filter.BinaryComparator',
                    serializedComparator: comparator.encode()
                  }
                }
              };
              return server.rpc.Mutate(req, cb);
            }
          });
        };
      })(this));
    };

    Client.prototype._multiAction = function(table, multiActions, useCache, retry, cb) {
      var req, result;
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
        retry = 0;
      } else if (typeof retry === 'function') {
        cb = retry;
        retry = 0;
      }
      req = {
        regionAction: []
      };
      result = [];
      return async.each(Object.keys(multiActions), (function(_this) {
        return function(serverName, done) {
          var actions, operations, region, _ref;
          _ref = multiActions[serverName];
          for (region in _ref) {
            actions = _ref[region];
            operations = [];
            operations = actions.map(function(action) {
              var _ref1;
              if (action.method === 'get') {
                return {
                  gxt: action.getFields()
                };
              } else if ((_ref1 = action.method) === 'put' || _ref1 === 'delete') {
                return {
                  mutation: action.getFields()
                };
              }
            });
            req.regionAction.push({
              region: {
                type: "REGION_NAME",
                value: region
              },
              action: operations
            });
          }
          return _this.getRegionConnection(serverName, function(err, server) {
            if (err) {
              return done(err);
            }
            return server.rpc.Multi(req, function(err, res) {
              var o, response, serverResult, _i, _j, _len, _len1, _ref1, _ref2;
              if (err) {
                return done(err);
              }
              _ref1 = res.regionActionResult;
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                serverResult = _ref1[_i];
                _ref2 = serverResult.resultOrException;
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  response = _ref2[_j];
                  o = _this._parseResponse(response.result);
                  if (o) {
                    result.push(o);
                  }
                }
              }
              return done();
            });
          });
        };
      })(this), function(err) {
        return cb(err, result);
      });
    };

    Client.prototype.getScanner = function(table, startRow, stopRow) {
      return new Scan(table, startRow, stopRow, this);
    };

    Client.prototype.get = function(table, get, cb) {
      debug("get on table: " + table + " get: " + (JSON.stringify(get)));
      return this._action('get', table, get, cb);
    };

    Client.prototype.checkAndPut = function(table, row, family, qualifier, value, put, cb) {
      var o;
      o = {
        row: row,
        family: family,
        qualifier: qualifier,
        value: value,
        op: put
      };
      debug("checkAndPut on table: " + table + " object: " + (JSON.stringify(o)));
      return this._action('checkAndPut', table, o, cb);
    };

    Client.prototype.checkAndDelete = function(table, row, family, qualifier, value, del, cb) {
      var o;
      o = {
        row: row,
        family: family,
        qualifier: qualifier,
        value: value,
        op: del
      };
      debug("checkAndDelete on table: " + table + " object: " + (JSON.stringify(o)));
      return this._action('checkAndDelete', table, o, cb);
    };

    Client.prototype.put = function(table, put, cb) {
      debug("put on table: " + table + " put: " + (JSON.stringify(put)));
      return this._action('put', table, put, cb);
    };

    Client.prototype["delete"] = function(table, del, cb) {
      debug("delete on table: " + table + " delete: " + (JSON.stringify(del)));
      return this._action('delete', table, del, cb);
    };

    Client.prototype.mget = function(table, rows, columns, opts, cb) {
      var column, get, row, workingList, _i, _j, _len, _len1;
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mget on table: " + table + " " + rows.length + " rows");
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      workingList = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        if (row instanceof Get) {
          get = row;
        } else {
          get = new Get(row);
          if (columns) {
            for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
              column = columns[_j];
              column = column.split(':');
              get.addColumn(column[0], column[1]);
            }
          }
        }
        get.method = 'get';
        workingList.push(get);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.mput = function(table, rows, opts, cb) {
      var column, columns, put, row, value, workingList, _i, _len;
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mput on table: " + table + " " + rows.length + " rows");
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      workingList = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        if (row instanceof Put) {
          put = row;
        } else {
          put = new Put(row.row);
          for (column in row) {
            value = row[column];
            if (column === 'row') {
              continue;
            }
            column = column.split(':');
            put.add(column[0], column[1], value);
          }
        }
        put.method = 'put';
        workingList.push(put);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.mdelete = function(table, rows, opts, cb) {
      var columns, del, row, workingList, _i, _len;
      if (!(Array.isArray(rows) && rows.length > 0)) {
        return cb("Input is expected to be a non-empty array");
      }
      debug("mdelete on table: " + table + " " + rows.length + " rows");
      if (typeof columns === 'function') {
        cb = columns;
        opts = {};
        columns = [];
      } else if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      workingList = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        if (row instanceof Delete) {
          del = row;
        } else {
          del = new Delete(row);
        }
        del.method = 'delete';
        workingList.push(del);
      }
      return this.processBatch(table, workingList, true, 0, function(err, results) {
        return cb(err, results);
      });
    };

    Client.prototype.increment = function(table, increment, cb) {
      debug("increment on table: " + table + " increment: " + (JSON.stringify(increment)));
      return this._action('increment', table, increment, cb);
    };

    Client.prototype.incrementColumnValue = function(table, row, cf, qualifier, value, cb) {
      var increment;
      increment = new Increment(row);
      increment.add(cf, qualifier, value);
      return this.increment(table, increment, cb);
    };

    Client.prototype.mutateRow = function() {
      throw new Error('mutateRow not implemented');
    };

    Client.prototype.append = function() {
      throw new Error('append is not implemented');
    };

    Client.prototype.getRowOrBefore = function() {
      throw new Error('getRowOrBefore is not implemented');
    };

    Client.prototype.processBatch = function(table, workingList, useCache, retry, cb) {
      var actionsByServer;
      if (typeof useCache === 'function') {
        cb = useCache;
        useCache = true;
      }
      actionsByServer = {};
      workingList.filter(function(item) {
        return item != null;
      });
      if (workingList.length === 0) {
        return cb(null, []);
      }
      return async.each(workingList, (function(_this) {
        return function(row, done) {
          return _this.locateRegion(table, row.getRow(), useCache, function(err, location) {
            var _base, _name, _name1;
            if (err) {
              return done(err);
            }
            if (actionsByServer[_name = location.server] == null) {
              actionsByServer[_name] = {};
            }
            if ((_base = actionsByServer[location.server])[_name1 = location.name] == null) {
              _base[_name1] = [];
            }
            actionsByServer[location.server][location.name].push(row);
            return done();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          }
          return _this._multiAction(table, actionsByServer, useCache, retry, cb);
        };
      })(this));
    };

    Client.prototype.prefetchRegionCache = function(table, cb) {
      var event, scan, startRow, stopRow, work;
      if (this._prefetchRegionCacheList[table] || utils.bufferCompare(table, hconstants.META_TABLE_NAME) === 0) {
        return cb();
      }
      debug("prefetchRegionCache for table: " + table);
      event = "prefetch-" + table;
      if (this._prefetchRegionCacheListInProgress[event]) {
        return this._prefetchRegionCacheListInProgress[event].push(cb);
      }
      this.once(event, (function(_this) {
        return function() {
          var callback, _results;
          _results = [];
          while (_this._prefetchRegionCacheListInProgress[event].length) {
            callback = _this._prefetchRegionCacheListInProgress[event].pop();
            _results.push(callback());
          }
          return _results;
        };
      })(this));
      this._prefetchRegionCacheListInProgress[event] = [];
      startRow = this.createRegionName(table, null, hconstants.ZEROS, false);
      stopRow = this.createRegionName(utils.bufferIncrement(table), null, hconstants.ZEROS, false);
      scan = this.getScanner(hconstants.META_TABLE_NAME, startRow, stopRow);
      work = true;
      return async.whilst(function() {
        return work;
      }, (function(_this) {
        return function(done) {
          return scan.next(function(err, regionRow) {
            var region;
            if (err) {
              return done(err);
            }
            if (!regionRow.row) {
              _this._prefetchRegionCacheList[table] = true;
              work = false;
              return done();
            }
            region = _this._parseRegionInfo(regionRow);
            if (region) {
              _this.cacheLocation(table, region);
            }
            return done();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log(err);
          }
          _this.emit(event);
          delete _this._prefetchRegionCacheListInProgress[event];
          return cb();
        };
      })(this));
    };

    Client.prototype.getRegionConnection = function(hostname, port, cb) {
      var server, serverName, timer, _ref;
      if (typeof port === 'function') {
        cb = port;
        serverName = hostname;
        _ref = hostname.split(':'), hostname = _ref[0], port = _ref[1];
      } else {
        serverName = this.getServerName(hostname, port);
      }
      rDebug('getRegionConnection', serverName);
      server = this.servers[serverName];
      if (server) {
        if (server.state === "ready") {
          rDebug("getRegionConnection from cache (servers: " + (Object.keys(this.servers).length) + "), " + serverName);
          cb(null, server);
        } else {
          server.on('ready', function() {
            return cb(null, server);
          });
        }
        return;
      }
      rDebug("getRegionConnection connecting to " + serverName);
      server = new Connection({
        host: hostname,
        port: port,
        rpcTimeout: this.rpcTimeout,
        callTimeout: this.callTimeout,
        logger: this.logger
      });
      server.state = "connecting";
      this.servers[serverName] = server;
      timer = null;
      timer = setTimeout((function(_this) {
        return function() {
          var err;
          err = ("" + serverName + " connect timeout, ") + _this.rpcTimeout + " ms";
          _this._handleConnectionError(err, serverName, timer);
        };
      })(this), this.rpcTimeout);
      server.once("connect", (function(_this) {
        return function() {
          rDebug("%s connected, total %d connections", serverName, Object.keys(_this.servers).length);
          server.state = "ready";
          server.emit('ready');
          clearTimeout(timer);
          timer = null;
          return cb(null, server);
        };
      })(this));
      server.once("connectError", this._handleConnectionError.bind(this, null, serverName, timer));
      return server.once("close", this._handleConnectionClose.bind(this, serverName));
    };

    Client.prototype._handleConnectionError = function(err, serverName, timer) {
      var server;
      rDebug("_handleConnectionError server: " + serverName + " msg: " + err.message);
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      if (err) {
        debug(err);
      }
      if (!this.servers[serverName]) {
        return;
      }
      server = this.servers[serverName];
      delete this.servers[serverName];
      server.removeAllListeners();
      return server.close();
    };

    Client.prototype._handleConnectionClose = function(serverName) {
      rDebug("_handleConnectionClose server: " + serverName);
      this.servers[serverName].removeAllListeners();
      delete this.servers[serverName];
      return this._clearCachedLocationForServer(serverName);
    };

    Client.prototype._clearCachedLocationForServer = function(serverName) {
      var region, regionName, regions, table, _ref, _results;
      _ref = this.cachedRegionLocations;
      _results = [];
      for (table in _ref) {
        regions = _ref[table];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (regionName in regions) {
            region = regions[regionName];
            if (region.server.toString() === serverName) {
              delete this.cachedRegionLocations[table];
              _results1.push(this._prefetchRegionCacheList[table] = false);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Client;

  })(EventEmitter);

}).call(this);
